---
title: "Charter Fishermen's Association Implementation Plan"
#date: "`r Sys.Date()`"
output: 
  #word_document: default
  #html_document: default
  bookdown::html_document2: 
    number_sections: false
  #bookdown::word_document2:
    #number_sections: false 
bibliography: references.bib
---

```{r setup, include=FALSE}
# Set global options for code chunks
# New defaults are to not evaluate code, include outputs, include the code, do not include messages or warnings
knitr::opts_chunk$set(echo = TRUE, include=TRUE, message=FALSE, warning=FALSE, eval=FALSE)
```

## Data Workflow

```{r workflow-img, eval=TRUE, echo=FALSE, fig.align = 'center', out.width = "100%", fig.cap = "Diagram depicting the proposed workflow of the Destin Charter Fishermen's Association communications network."}
# (Figure \@ref(fig:workflow-img))
knitr::include_graphics("figures/NFWF_Data_Workflow.png")
```

*To demonstrate the data workflow of the implementation plan, R [@base] and Shiny [@shiny] will be used for example code. A live version of the example application can be found at [https://cfemm.shinyapps.io/destin-app](https://cfemm.shinyapps.io/destin-app/).*

### A. Network participants record observations at sea

a.  **Network participants:** Professional charter captains from Destin, FL with federal reef fish permits are selected by founding members and subject to non-disclosure agreements. There is a potential pool of \~60 charter and 30-40 commercial permitted vessels active. Nine captains produce \~1,700 trips annually.

b.  **Observations at-sea:** Users record the presence/absence or intensity of depredators and the strength of currents while at sea, which is anticipated to be 10s to 100s of observations per day fleet-wide. Additional observations to record can be phased-in such as discards, metered (YSI) environmental conditions, bait availability, tidelines, obstructions, water clarity, and red-tide.

### B. Data is recorded and mapping products are received via web-based application

a.  **Data recorded:** Recordings take place within a simple app interface (Figure \@ref(fig:ui-img)). for near real-time data entry and viewing, with optional delayed manual entry. Depredation, sharks, dolphins, and current strengths are reported as “none”, “moderate”, or “high”, with their values decided by the user group (e.g. “None”= 0 instances, “Moderate” = 1-3 instances, “High” = 4+ instances). Discards are a possible future addition. “Notes” are optional.

```{r ui-img, eval=TRUE, echo=FALSE, fig.align = 'center', out.width = "100%", fig.cap = "An example user interface for recording observations."}
# (Figure \@ref(fig:ui-img))
knitr::include_graphics("figures/CFA_record_ui.png")
```

``` {r record-data}
# B(a). User interface for recording observations. 

############ ui.R ############

tabItem(tabName="recordtab",
  fluidRow(
    box(width=12, status="primary", title="Record New Observation", solidHeader=TRUE,
      helpText("Please enter your observations using the following inputs."),
        fluidRow(
          column(width=4, pickerInput("select_current", label = "Current Intensity", 
            choices = c("None", "Moderate", "High"), selected = "None",
            choicesOpt = list(
              content = sprintf("<span class='label label-%s'>%s</span>",
                c("success", "warning", "danger"),
                c("None", "Moderate", "High"))
          ))),
          column(width=4, pickerInput("select_depred", label = "Depredation Intensity", 
            choices = c("None", "Moderate", "High"), selected = "None",
            choicesOpt = list(
              content = sprintf("<span class='label label-%s'>%s</span>",
                c("success", "warning", "danger"),
                c("None", "Moderate", "High"))
          ))),
          column(width=4, pickerInput("select_species", label = "Species Encountered", 
            choices = c("None","Shark", "Dolphin"), selected = "None",
            choicesOpt = list(
              content = sprintf("<span class='label label-%s'>%s</span>",
                c("success", "primary", "info"),
                c("None", "Shark", "Dolphin"))
          )))
        ), 
        fluidRow(
          column(width=4, radioButtons("check_loc", 
            label = "Use Current Location", c("Yes", "No"), selected = "Yes")),
          column(width=4, conditionalPanel(condition="input.check_loc == 'No'",
            textInput("text_long", label = "Longitude"))),
          column(width=4, conditionalPanel(condition="input.check_loc == 'No'",
            textInput("text_lat", label = "Latitude")))
        ), 
        fluidRow(
          column(width=8, textInput("text_notes", label="Notes"))
        ), 
        actionButton("submit", "Submit Data", class="btn btn-primary", style = "color: white;")
    )
  ) 
)
```

b.  **Mapping products:** Real-time fisheries reports are shown as grids/heat maps overlaid on a digital basemap, including selectable environment layers (surface temperature or water clarity; via remote sensing) in the future.

c.  **Web-based application:** Potential platforms/developers are to be determined by network participants. Users are required to register for an account in order to password-protect access to grouped data and display personalized information (user-specific history of recorded point data).

```{r B-c, eval=FALSE}

# B(c). Users must register for an account in order to password-protect access to data.

############ preprocess.R ############

# Create an example for a fixed userbase and hash the passwords
user_base <- tibble::tibble(
  user = c("cfemm-admin", "test-user"),
  password = purrr::map_chr(c("temp", "hotspots"), sodium::password_store),
  permissions = c("admin", "standard"),
  name = c("Admin Account", "Test User")
)

############ server.R ############

# Hide the UI until credentials are satisfied
shinyjs::hide(id="main_ui")

# Load the userbase created and initialize the login panel
credentials <- shinyauthr::loginServer(
  id = "login",
  data = user_base,
  user_col = user,
  pwd_col = password,
  sodium_hashed = TRUE,
  log_out = reactive(logout_init())
)

# Initialize the logout panel and listen for logouts
logout_init <- shinyauthr::logoutServer(
  id = "logout",
  active = reactive(credentials()$user_auth)
)

# Use the username as the User ID for recording observations  
observeEvent(credentials()$user_auth, {
  if (credentials()$user_auth) {
    session$userData$user_id <- credentials()$info$user
    # Show UI when logged in
    shinyjs::show(id = "main_ui")  
  } else {
    # Hide UI on logout
    shinyjs::hide(id = "main_ui")
  }
})
```

### C. Satellite communication through Starlink provides internet access

a.  **Starlink communication:** Starlink is integrated with existing onboard networks via wireless router. Users connect to the application through an internet browser on a computer or mobile device. 

### D. A cloud-based server updates the user with maps using a time-slice view

a.  **Integrated maps:** Interactive displays of map data may use platforms such as Google Maps API, Mapbox API, or Leaflet (as exemplified here). The basemap utilizes provider tiles such as the “Esri World Ocean Basemap” to include basic bathymetric visualizations. A geolocation API will display the current location of the vessel. User-specified inputs determine display details for the density rasters or grid polygons. Publicly available environmental data can be integrated as additional layers.

b.  **Time-slice view:** The slider tool enables data filtering from 24 hours to 30 days since the observations were recorded. Data can be weighted to place more “statistical emphasis” on observations that occurred most recently. User-specific point data may “fade” with time since recording.

### E. Gulf Fisheries Research Foundation (GFRF) serves as the institutional home for the implementation plan

a.  **Institutional home:** GFRF is the research arm of the Charter Fishermen’s Association (CFA) and can provide an administrative and managerial role for other local CFA networks.

b.  **Implementation plan:** The plan includes membership information, Starlink subscriptions, database management, and server/code updates for the web application.

### F. Code cleans inputs and processes raw data for integration into grid cells or heatmaps

a.  **Cleans inputs:** Code parses date-time and lat-long data into a consistent format. Manual entry is restricted to feasible dates and ranges by utilizing error-handling pop-up messages.

``` {r clean-inputs}
# F(a). Code cleans inputs and handles errors.

############ server.R ############

# Create a reactiveValues object to store the Google Sheet data
data_store <- reactiveValues(data = NULL)
  
# Function to fetch and update the data from Google Sheet
update_sheet_data <- function() {
    tryCatch({
      sheet_data <- read_sheet(ss = sheet_id, sheet = "main")
      showNotification("Data updated successfully", type="message")
    }, error = function(e) {
      showNotification("Error reading Google Sheet", type="error")
      print(paste("Error reading sheet:", e))
    })
  }

# Record data upon clicking "Submit" button
observeEvent(input$submit, {
    
    # Prevent duplicate entries due to double-clicking
    shinyjs::disable("submit")
    
    # Record timestamp
    timestamp <- Sys.time()
    
    # Record user ID
    user_id <- session$userData$user_id
    
    # Handle Lat/Lon entries
    lon <- if (input$check_loc == "Yes") {
      showNotification("Unable to retrieve location. Please enter manually.", type = "error")
      shinyjs::enable("submit")
      return(NULL)
    } else {
      as.numeric(input$text_long)
    }
    
    if (is.na(lon) || lon > -82.996 || lon < -90.500) {
      showNotification("Please enter a valid longitude between -89W and -83W.", type = "error")
      shinyjs::enable("submit")
    }
    
    lat <- if (input$check_loc == "Yes") {
      showNotification("Unable to retrieve location. Please enter manually.", type = "error")
      shinyjs::enable("submit")
      return(NULL)
    } else {
      as.numeric(input$text_lat)
    }
    
    if (is.na(lat) || lat < 28.90000 || lat > 30.692) {
      showNotification("Please enter a valid latitude between 28.9N and 30.5N.", type = "error")
      shinyjs::enable("submit")
    }
    
    # Record notes
    notes <- if (input$text_notes == "") {
      NA
    } else {
      input$text_notes
    }
    
    # Compile responses into a data frame
    response_data <- data.frame(
      current = input$select_current,
      depred = input$select_depred,
      species = input$select_species,
      latitude = lat,
      longitude = lon,
      notes = notes,
      timestamp = timestamp,
      user_id = as.character(user_id)
    ) 
    
    values <- read_sheet(ss = sheet_id, sheet="main")
    
    # Merge the new responses with the existing Google Sheet
    tryCatch({
    if (nrow(values) == 0) {
      sheet_write(data = response_data,
                  ss = sheet_id,
                  sheet = "main")
    } else {
      sheet_append(data = response_data,
                   ss = sheet_id,
                   sheet = "main")
    }
      
    # Handle Google Sheet connectivity errors
    update_sheet_data()
    }, error = function(e) {
      showNotification("Error writing to Google Sheet", type="error")
    })
    
    # Enable submit button once data is written
    shinyjs::enable("submit")
    
  })
```

b.  **Data processing:** Depredation and current strength observations (“None”, “Moderate”, or “High”) are translated into numerical inputs. Points within a 1-sq mile grid cell are averaged to determine a ‘stoplight color’ classification of the cell to depict areas to avoid or target (Figure \@ref(fig:grid-img)). Heat maps are developed by filtering the data by the user’s input, computing an appropriate bandwidth, followed by a 2D binned kernel density estimate which is converted to a raster for visualizing high (warm colors) or low (cool colors) point density (Figure \@ref(fig:heat-img)). Computations would be made on network-wide observations (not for current strength), but users may only view their own recorded data points.

```{r grid-img, eval=TRUE, echo=FALSE, fig.align = 'center', out.width = "100%", fig.cap = "Example map displaying depredation intensity in 1 mi by 1 mi grid cells."}
# (Figure \@ref(fig:grid-img))
knitr::include_graphics("figures/CFA_grid_map.png")
```

```{r heat-img, eval=TRUE, echo=FALSE, fig.align = 'center', out.width = "100%", fig.cap = "Example heat map displaying density of depredation events."}
# (Figure \@ref(fig:heat-img))
knitr::include_graphics("figures/CFA_heat_map.png")
```

c.  **Mapping:** Maps are reactive to additional observations recorded, and any filters that the user defines (e.g. time slider, depredation vs current, etc.). Grid or heat map display may be toggled depending on user preference (Figure \@ref(fig:filter-img)). User-specific point data may also be viewed on the "User Data" page. Users can select grid cells or point data to view details, “Notes” recorded, or obtain coordinates from the map by mousing-over it.

```{r filter-img, eval=TRUE, echo=FALSE, fig.align = 'center', out.width = "25%", fig.cap = "User input options available to display layers on the main map."}
# (Figure \@ref(fig:filter-img))
knitr::include_graphics("figures/CFA_ui_inputs.png")
```

### G. Data is stored for future analysis on long-term trends and predictive modeling

a.  **Data storage:** Each observation recorded has an observation ID, user ID, and timestamp that is appended at the time of entry and uploaded to the master database. The data is stored in a cloud-based relational database, such as MySQL or SQL Server, in order to maintain security, scalability, and speed (Google Sheets is utilized in this example). All data is accessible to GFRF, grouped data are accessible to all users, and user-specific data is only accessible to the specified user (Figure \@ref(fig:table-img)).

```{r table-img, eval=TRUE, echo=FALSE, fig.align = 'center', out.width = "100%", fig.cap = "User-specific information is recorded at the time of observation and only made available to the specified user."}
# (Figure \@ref(fig:table-img))
knitr::include_graphics("figures/CFA_user_table.png")
```

b.  **Future analyses:** Long-term trends (e.g. GAMs) and predictive modeling based on network-reported data may be updated on a rolling basis as determined by GFRF. Results could be sent as alerts by email or text to users on areas to avoid within a certain time frame. There is potential for the use of data recorded by the participants in reports to NMFS for electronic logbook, stock assessments, etc.

## Complete Code

### Directory Organization

The file structure for this application is as follows:

```
└── 📁app
    └── 📁.secrets
        └── secret-token
    └── 📁data
        └── preprocess.RData                              
    └── 📁shapefiles
        └── destin_1mi.cpg
        └── destin_1mi.dbf
        └── destin_1mi.prj
        └── destin_1mi.sbn
        └── destin_1mi.sbx
        └── destin_1mi.shp
        └── destin_1mi.shp.xml
        └── destin_1mi.shx
    └── 📁www
        └── boat.svg
        └── cfa-logo.png
    └── global.R
    └── preprocess.R
    └── server.R
    └── ui.R
```

### Limitations

Importantly, the example application is currently incapable of performing two critical functions:

1. The app cannot utilize georeferencing to determine the user's location which is needed for updating the map's location marker and automatically assigning coordinates to newly recorded observations.

2. Users are unable to modify or delete recorded observations once submitted to the database. The administrator must manually service these requests.

### preprocess.R

This script preprocesses data need in the server and user interface of the app.

```{r preprocess, echo=FALSE}
# Load packages for preprocessing
{
  library(tidyverse)
  library(data.table)
  library(lubridate)
  library(sf)
  library(leaflet)
  library(googledrive)
  library(googlesheets4)
  library(digest)
}

{
# Set global options for handling Google Sheets token
options(
  gargle_oauth_email=TRUE,
  gargle_oauth_cache = "/.secrets",
  gargle_oauth_path = NULL
)

# To be done once upon initializing the desired Google Sheet
# gs4_create(name="cfa-test-sheet",
#            sheets="main")

# Assign Google Sheet ID
sheet_id <- drive_get("cfa-test-sheet")$id

# Read NOAA Observer data and format columns
Data.In <- fread("destin-app/data/NOAA-Observer-data.csv")
{noaa_data=Data.In
noaa_data <- noaa_data %>% dplyr::filter(COMMON_NAME != "" | SET_TIME_START != "") #| VESSEL_ID != "")
noaa_data$SET_TIME_START_dt <- parse_date_time(noaa_data$SET_TIME_START, "d-b-y I.M.S.p")
noaa_data$SET_TIME_END_dt <- parse_date_time(noaa_data$SET_TIME_END, "d-b-y I.M.S.p")
noaa_data$DEPART_DATE_dt <- mdy(noaa_data$DEPART_DATE)
noaa_data$LAND_DATE_dt <- mdy(noaa_data$LAND_DATE)
noaa_data$SET_YEAR <- year(noaa_data$SET_TIME_START_dt)
noaa_data$SEA_DAYS <- as.numeric(difftime(noaa_data$LAND_DATE_dt, noaa_data$DEPART_DATE_dt, units = "days"))
}

# Function to generate random alphanumeric string of the same length
random_string <- function(n) {
  paste(sample(c(0:9, letters, LETTERS), n, replace = TRUE), collapse = "")
}

# Create a function to map unique values to random strings
random_mask <- function(column) {
  # Get unique values in the column
  unique_values <- unique(column)
  
  # Generate random strings for each unique value, with the same length as the original value
  masked_values <- sapply(nchar(unique_values), random_string)
  
  # Create a mapping table (dictionary)
  value_map <- setNames(masked_values, unique_values)
  
  # Replace the original values with their masked versions
  return(value_map[column])
}

# Mask columns with sensitive information
{noaa_data$VESSEL_ID <- random_mask(noaa_data$VESSEL_ID)
noaa_data$TRIPNUMBER <- random_mask(noaa_data$TRIPNUMBER)
noaa_data$UNIQUE_RETRIEVAL <- paste(noaa_data$VESSEL_ID, noaa_data$TRIPNUMBER, noaa_data$SETNUMBER, sep="_")
}

# Filter NOAA observer data for vertical line gear near Destin
noaa_vl_des <- noaa_data %>%
  filter(TRIP_GEAR == 'VL' & COMMON_NAME != "NOCATCH" & LON_BEGIN_SET > -89 & LAT_BEGIN_SET > 29 & !is.na(SET_TIME_START)) %>%
  mutate(Effort_ID = dense_rank(TRIPNUMBER)) %>%
  group_by(TRIPNUMBER) %>%
  mutate(Days_Report = dense_rank(as.Date(SET_DATE, format="%m/%d/%Y"))) %>%
  ungroup()

# Load shapefile for 1mi by 1mi grid
gridshp <- st_read(dsn="shapefiles", layer = "destin_1mi")

# Determine bounding box for shapefile limits
bbox <- st_bbox(gridshp)

# Create icon for boat and make static legend
boat_icon <- makeIcon(iconUrl = "www/boat2.svg",
                      iconWidth=35, iconHeight=30, 
                      iconAnchorX=15, iconAnchorY=15)
html_legend <- "<img src='boat2.svg' style='width:35px;height:30px;'> Current Location<br/>"

# Read historic current speed data
current_speed <- fread("destin-app/data/Oceanic_current_speed.csv") %>%
  dplyr::select(Longitude, Latitude, Oceanic_current_speed_October) %>%
  rename("Speed_Oct" = "Oceanic_current_speed_October")

# Convert the current speed data frame to a spatial object
current_speed_sf <- st_as_sf(current_speed, coords = c("Longitude", "Latitude"), crs = st_crs(gridshp))

# Perform the spatial join for current speed data and grid
grid_join_c <- setDT(st_join(current_speed_sf, gridshp, join = st_intersects))

# Assign bins to current speed data
filtered_data_c <- grid_join_c %>%
    group_by(GRID_ID) %>%
    summarise(
      speed_mean = mean(Speed_Oct, na.rm = TRUE)
    ) %>%
  mutate(class_bin = case_when(
    speed_mean >= 0.5 ~ 3,
    speed_mean >= 0.3 ~ 2,
    speed_mean < 0.3 ~ 1
  ))

# Determine grid values for current speed data
gridvalues_c <- st_as_sf(merge(x = gridshp, y = filtered_data_c, by = "GRID_ID", all.x = FALSE))

# create an example for a fixed userbase and hash the passwords
user_base <- tibble::tibble(
  user = c("cfemm-admin", "test-user"),
  password = purrr::map_chr(c("temp", "hotspots"), sodium::password_store),
  permissions = c("admin", "standard"),
  name = c("Admin Account", "Test User")
)

# Save variables for use in the server
save(gridshp, sheet_id, noaa_data, noaa_vl_des, boat_icon, html_legend, user_base, file = "destin-app/data/preprocess.RData")
}
```

### global.R

This script loads data and packages needed in the server and user interface of the app.

```{r global, echo=FALSE}
# Load packages for the entire app
{
  library(tidyverse)
  library(data.table)
  library(lubridate)
  library(spatial)
  library(sp)
  library(sf)
  library(spdep)
  library(sfdep)
  library(fields)
  library(RColorBrewer)
  library(leaflet)
  library(kableExtra)
  library(shiny)
  library(plotly)
  library(htmlwidgets)
  library(shinyWidgets)
  library(shinycustomloader)
  library(leaflet.extras)
  library(leaflet.extras2)
  library(leafem)
  library(DT)
  library(shinydashboard)
  library(googledrive)
  library(googlesheets4)
  library(digest)
  library(shinyauthr)
  library(sodium)
}

# Load data made in the preprocessing file
load("preprocess.RData")

# Set Google sheet information
googledrive::drive_auth(cache = ".secrets", email = "example@email.com")
googlesheets4::gs4_auth(token = drive_token())
```

### server.R

This script contains the server and all reactive objects needed to handle events.

```{r server, echo=FALSE}
function(input, output, session) {

# Handle user authentication by only showing the main user interface when credentials are satisfied
  shinyjs::hide(id="main_ui")

  credentials <- shinyauthr::loginServer(
    id = "login",
    data = user_base,
    user_col = user,
    pwd_col = password,
    sodium_hashed = TRUE,
    log_out = reactive(logout_init())
  )

  logout_init <- shinyauthr::logoutServer(
    id = "logout",
    active = reactive(credentials()$user_auth)
  )
  
  observeEvent(credentials()$user_auth, {
    if (credentials()$user_auth) {
      session$userData$user_id <- credentials()$info$user
      shinyjs::show(id = "main_ui")  # Show UI when logged in
    } else {
      shinyjs::hide(id = "main_ui")  # Hide UI on logout
    }
  })
  
# create modal dialog as a welcome/landing page
  observe({
    req(credentials()$info)
    showModal(
      ui = modalDialog(
        title = "Welcome to the Charter Fishermen's Association Hotspot Mapper",
        tags$div(
          tags$p("This app allows you to filter data on a map, record new observations, and view your own recorded data over time."),
          tags$h4("How to Use the App:"),
          tags$ul(
            tags$li("Use the filters in the sidebar to view all data in the Map tab."),
            tags$li("Share your observations on the water in the Record New Observations tab."),
            tags$li("View your own observations in the User Data tab.")
          ),
        ),
        footer = tags$p(style="text-align:center;", tags$em("Data collected through this app is confidential and only accessible to approved members.")),
        easyClose = TRUE,
        fade = TRUE
      )
    )
  })
  
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #  
  # if (is.null(session$userData$user_id)) {
  #   session$userData$user_id <- paste0("user_", substr(digest::digest(Sys.time()), 1, 8))
  # }
    
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 
  
  # Create a reactiveValues object to store the Google Sheets data
  data_store <- reactiveValues(data = NULL)
  
  # Function to fetch and update the data from Google Sheets
  update_sheet_data <- function() {
    tryCatch({
      sheet_data <- read_sheet(ss = sheet_id, sheet = "main")
      data_store$data <- sheet_data  # Update the reactive value
      showNotification("Data updated successfully", type="message")
    }, error = function(e) {
      showNotification("Error reading Google Sheet", type="error")
      print(paste("Error reading sheet:", e))
    })
  }
  
  # Fetch initial data on app startup
  update_sheet_data()
  
  observeEvent(input$submit, {
    #showNotification("submit button pressed")
    #print("submit button pressed")
    shinyjs::disable("submit")
    
    timestamp <- Sys.time()
    
    user_id <- session$userData$user_id
    
    # Check if the user wants to use the current location
    
    lon <- if (input$check_loc == "Yes") {
      #-88.9 #NA #input$user_long
      showNotification("Unable to retrieve location. Please enter manually.", type = "error")
      shinyjs::enable("submit")
      return(NULL)
    } else {
      as.numeric(input$text_long)
    }
    
    if (is.na(lon) || lon > -82.996 || lon < -90.500) {
      showNotification("Please enter a valid longitude between -89W and -83W.", type = "error")
      shinyjs::enable("submit")
      return(NULL)  # Stop further execution if longitude is invalid
    }
    
    lat <- if (input$check_loc == "Yes") {
      #29 #NA #input$user_lat
      showNotification("Unable to retrieve location. Please enter manually.", type = "error")
      shinyjs::enable("submit")
      return(NULL)
    } else {
      as.numeric(input$text_lat)
    }
    
    if (is.na(lat) || lat < 28.90000 || lat > 30.692) {
      showNotification("Please enter a valid latitude between 28.9N and 30.5N.", type = "error")
      shinyjs::enable("submit")
      return(NULL)  # Stop further execution if latitude is invalid
    }
    
    notes <- if (input$text_notes == "") {
      NA
    } else {
      input$text_notes
    }
    
    # compile repsonses into a data frame
    response_data <- data.frame(
      current = input$select_current,
      depred = input$select_depred,
      species = input$select_species,
      latitude = lat,
      longitude = lon,
      notes = notes,
      timestamp = timestamp,
      user_id = as.character(user_id)
    ) 
    #df(dplyr::bind_rows(df(), response_data))
    #showNotification("Response data created")
    
    values <- read_sheet(ss = sheet_id, sheet="main")
    
    #showNotification(paste("Rows in sheet:", nrow(values)))
    # Check to see if our sheet has any existing data.
    # If not, let's write to it and set up column names. 
    # Otherwise, let's append to it.
    
    # merge the new responses with the existing google sheet
    tryCatch({
    if (nrow(values) == 0) {
      #showNotification("Writing new data to sheet")
      sheet_write(data = response_data,
                  ss = sheet_id,
                  sheet = "main")
    } else {
      #showNotification("Appending data to sheet")
      sheet_append(data = response_data,
                   ss = sheet_id,
                   sheet = "main")
      #showNotification("Data recorded successfully", duration=5, type="message")
    }
      
    # handle errors
    update_sheet_data()
    }, error = function(e) {
      showNotification("Error writing to Google Sheet", type="error")
    })
    
    shinyjs::enable("submit")
    
  }) # end observe event
  
  # testvalues <- read_sheet(ss = sheet_id, sheet="main")
  # print(testvalues)
  
  # debugging
  # observe({
  #   if (!is.null(data_store$data)) {
  #     print(sapply(data_store$data, class))  # Print the class of each column
  #   }
  # })
  
  #observe({
  # output$sheet_data <- DT::renderDT({
  #   #read_sheet(ss = sheet_id, sheet = "main")
  #   req(data_store$data)
  #   data_store$data
  # })
  #})

################################################################################
  
# filter dataset based on user inputs  
filtered_prop <- reactive({
    noaa_vl_des %>% filter(Days_Report <= input$days[1])#,
                           #Days_Report <= input$days[1])#,
                           #Effort_ID <= input$effort)
})

# check number of vessels included
  # dep_vess <- noaa_vl_des %>% filter(Days_Report == 1, 
  #                                    CONDITION == "DEAD")
  # n_distinct(dep_vess$VESSEL_ID)

noaa_vl_prop <- reactive({
  filtered_prop() %>% 
  filter(!is.na(LAT_BEGIN_SET) & !is.na(LON_BEGIN_SET)) %>%
  group_by(UNIQUE_RETRIEVAL, COMMON_NAME, VESSEL_ID) %>%
  mutate(
    NUM_ALIVE = sum(NUM_FISH[CONDITION %in% c('ALIVE', 'ALIVE BAURO - STOM/BLADDER', 'ALIVE BAURO - EYES', 'ALIVE BAURO - BOTH')]),
    NUM_DEAD = sum(NUM_FISH[CONDITION == 'DEAD']),
    UNIQUE_RET_LAT = round(mean(LAT_BEGIN_SET), 6),
    UNIQUE_RET_LON = round(mean(LON_BEGIN_SET), 6),
    PROP_DEAD = NUM_DEAD / NUM_ALIVE,
    NUM_SHARKS = sum(NUM_FISH[grepl("SHARK", COMMON_NAME)])
    )
})

# Convert the data frame to a spatial object
noaa_vl_prop_sf <- reactive({st_as_sf(noaa_vl_prop(), coords = c("UNIQUE_RET_LON", "UNIQUE_RET_LAT"), crs = st_crs(gridshp))})

# Perform the spatial join
grid_join <- reactive({setDT(st_join(noaa_vl_prop_sf(), gridshp, join = st_intersects))})
#grid_join_dt <- setDT(grid_join)

# filter and aggregate the data if the cells contain at least 3 vessels contributing
filtered_data <- reactive({
  grid_join() %>%
    group_by(GRID_ID) %>%
    dplyr::reframe(
      PROP_DEAD.mean = mean(PROP_DEAD, na.rm = TRUE),  # Calculate the mean PROP_DEAD for each grid
      NUM_SHARKS.mean = mean(NUM_SHARKS, na.rm=TRUE),
      num_points = n(),  # Count the number of points in each grid
      unique_vessel_ids = n_distinct(VESSEL_ID)  # Count unique VESSEL_IDs in each grid
    ) %>%
    filter(num_points >= 3 & unique_vessel_ids >= 3)  # Apply the filtering condition: at least 3 points and at least 3 unique VESSEL_IDs
})

filtered_data2 <- reactive({
  filtered_data() %>%
  filter(GRID_ID != "NA",
    PROP_DEAD.mean != 'Inf') %>%
  mutate(
    depred_class = case_when(
      PROP_DEAD.mean == 0 ~ 'None',
      PROP_DEAD.mean <= 0.10 ~ 'Moderate',
      PROP_DEAD.mean > 0.10 ~ 'High'
    ),
    current_class = "None",
    sharks_class = case_when(
      NUM_SHARKS.mean == 0 ~ "None",
      NUM_SHARKS.mean <= 2 ~ "Moderate",
      NUM_SHARKS.mean > 2 ~ "High"
    ),
    dolphins_class = "None"
  )
})

# Merge the results back with the grid shapefile
gridvalues <- reactive({st_as_sf(merge(x = gridshp, y = filtered_data2(), by = "GRID_ID", all.x = FALSE))})

suppressWarnings(
  grid_centroids <- reactive({
    st_centroid(gridvalues()) %>% select(GRID_ID, depred_class, current_class, sharks_class, dolphins_class, num_points)
  })
)
# grid_centroids_sd <- reactive({
#   st_centroid(gridvalues()) %>% filter(depred_class != "None")
# })

######################################### user data

user_data <- reactive({data_store$data %>% #data_store$data %>% sheet_data %>% 
  filter(!is.na(longitude) & !is.na(latitude)) %>%
  mutate(
    current_bin = case_when(
      current == "None" ~ 1,
      current == "Moderate" ~ 2,
      current == "High" ~3
    ),
    depred_bin = case_when(
      depred == "None" ~ 1,
      depred == "Moderate" ~ 2,
      depred == "High" ~3
    )
  )
})

user_data_sf <- reactive({st_as_sf(user_data(), coords = c("longitude", "latitude"), crs = st_crs(gridshp))})
grid_join_u <- reactive({setDT(st_join(user_data_sf(), gridshp, join = st_intersects))})

filtered_data_u <- reactive({
  threshold_time <- Sys.time() - as.difftime(input$days, units = "days")
  
  grid_join_u() %>%
    filter(!is.na(GRID_ID),
           timestamp >= threshold_time) %>%
    group_by(GRID_ID) %>%
    dplyr::reframe(
      current.mean = mean(current_bin, na.rm = TRUE), 
      depred.mean = mean(depred_bin, na.rm=TRUE),
      num_points = n(),
      current_class = case_when(
        current.mean == 1 ~ "None",
        current.mean <= 2 ~ "Moderate",
        current.mean > 2 ~ "High"
      ),
      depred_class = case_when(
        depred.mean == 1 ~ "None",
        depred.mean <= 2 ~ "Moderate",
        depred.mean > 2 ~ "High"
      ),
      sharks_class = case_when(
        species == "None" ~ "None",
        species == "Dolphin" ~ "None",
        species == "Shark" & depred.mean == 1 ~ "None",
        species == "Shark" & depred.mean <= 2 ~ "Moderate",
        species == "Shark" & depred.mean > 2 ~ "High"
      ),
      dolphins_class = case_when(
        species == "None" ~ "None",
        species == "Shark" ~ "None",
        species == "Dolphin" & depred.mean == 1 ~ "None",
        species == "Dolphin" & depred.mean <= 2 ~ "Moderate",
        species == "Dolphin" & depred.mean > 2 ~ "High"
      ),
      all_notes = paste(notes[!is.na(notes)], collapse = ";<br> "),
      num_points = n()
    )
})

gridvalues_u <- reactive({st_as_sf(merge(x = gridshp, y = filtered_data_u(), by = "GRID_ID", all.x = FALSE))})

suppressWarnings(
  grid_centroids_u <- reactive({
    st_centroid(gridvalues_u()) %>% select(GRID_ID, depred_class, current_class, sharks_class, dolphins_class, num_points)
  })
)
  
suppressWarnings(
  all_centroids <- reactive({rbind(grid_centroids(), grid_centroids_u())})
)

#########################################

# map with proxy
  output$examplemap <- renderLeaflet({
    req(credentials()$info)
    showNotification("Update map in order to view data", duration=30, closeButton=TRUE)
    leaflet() %>%
      addProviderTiles("Esri.NatGeoWorldMap", options = providerTileOptions(minZoom = 6, maxZoom = 10)) %>%
      setView(lng=-86.75, lat=29.75, zoom=9)  %>%
      addScaleBar(position = 'topleft',
                  options = scaleBarOptions(maxWidth = 100, metric = TRUE, imperial = TRUE, updateWhenIdle = FALSE)) 
  })
  
colors <- c("#00a65a", "#f39c12", "#dd4b39")
pro_levels <- c("None", "Moderate", "High")
pro_pal <- colorFactor(colors, levels=pro_levels, domain=c("None", "Moderate", "High"))

  observeEvent(input$update, {
    
    #print(nrow(gridvalues()))
    #print(filtered_data2())
    #print(grid_centroids())
    #print(all_centroids())
    
    popper <- paste0("<strong>Notes: </strong>observer data")
    poppy <- paste0("<strong>Notes: </strong>", gridvalues_u()$all_notes)
    
    # valid_data <- data_store$data %>%
    #   dplyr::filter(!is.na(latitude) & !is.na(longitude))
    
    proxy <- leafletProxy("examplemap")
      
    proxy %>% 
      clearHeatmap() %>%
      clearShapes() %>%
      clearImages() %>%
      clearControls() %>%
      leafem::addMouseCoordinates() %>%
      addMarkers(lng=-86.3, #input$user_long
                 lat=30.25, #input$user_lat
                 icon=boat_icon) %>%
      addSimpleGraticule(interval = 1, 
                         group = "Graticule") %>%
      addControl(html=html_legend, position="topright") %>%
      addLayersControl(position="topleft", overlayGroups = c("Graticule"), 
                       options=layersControlOptions(collapsed=FALSE))
    
    if (input$radio_depred == "Total" & input$radio_layer == "Intensity (grid)"){
    proxy %>%
      addPolygons(data = gridvalues(),
                  fillColor = ~pro_pal(depred_class),
                  weight = 0.5,
                  color = "black",
                  fillOpacity = 1,
                  highlightOptions = highlightOptions(color = "white", weight = 2, bringToFront = TRUE),
                  popup = ~popper,
                  group = "Depredation Intensity") %>%
        addPolygons(data = gridvalues_u(),
                    fillColor = ~pro_pal(depred_class),
                    weight = 0.5,
                    color = "black",
                    fillOpacity = 1,
                    highlightOptions = highlightOptions(color = "white", weight = 2, bringToFront = TRUE),
                    popup = ~poppy,
                    group = "Depredation Intensity") %>%
        leaflet::addLegend(position = 'topright',
                           pal = pro_pal,
                           values = c("None", "Moderate", "High"),
                           opacity = 1,
                           title = HTML("Depredation<br>Intensity"),
                           group = "Depredation Intensity",
                           layerId = "Depredation Intensity") 
    }  
      
    if (input$radio_depred == "Total" & input$radio_layer == "Density (heat)"){
    proxy %>% 
      addHeatmap(data = all_centroids() %>% filter(depred_class != "None"),
        #gradient = "Spectral",
        intensity = ~num_points,
        blur = 35,
        #max = 0.05,
        radius = 30,
        group = "Catch Density")
    }  
    
    if (input$radio_depred == "Sharks" & input$radio_layer == "Intensity (grid)"){
      proxy %>%
        addPolygons(data = gridvalues(),
                    fillColor = ~pro_pal(sharks_class),
                    weight = 0.5,
                    color = "black",
                    fillOpacity = 1,
                    highlightOptions = highlightOptions(color = "white", weight = 2, bringToFront = TRUE),
                    popup = ~popper,
                    group = "Shark Intensity") %>%
        addPolygons(data = gridvalues_u(),
                    fillColor = ~pro_pal(sharks_class),
                    weight = 0.5,
                    color = "black",
                    fillOpacity = 1,
                    highlightOptions = highlightOptions(color = "white", weight = 2, bringToFront = TRUE),
                    popup = ~poppy,
                    group = "Shark Intensity") %>%
        leaflet::addLegend(position = 'topright',
                           pal = pro_pal,
                           values = c("None", "Moderate", "High"),
                           opacity = 1,
                           title = HTML("Shark Intensity"),
                           group = "Shark Intensity",
                           layerId = "Shark Intensity") 
    }
    
    if (input$radio_depred == "Sharks" & input$radio_layer == "Density (heat)"){
      proxy %>% 
        addHeatmap(data = all_centroids() %>% filter(sharks_class != "None"),
                   #gradient = "Spectral",
                   intensity = ~num_points,
                   blur = 35,
                   #max = 0.05,
                   radius = 30,
                   group = "Shark Density")
    } 
    
    if (input$radio_depred == "Dolphins" & input$radio_layer == "Intensity (grid)"){
      proxy %>%
        addPolygons(data = gridvalues(),
                    fillColor = ~pro_pal(dolphins_class),
                    weight = 0.5,
                    color = "black",
                    fillOpacity = 1,
                    highlightOptions = highlightOptions(color = "white", weight = 2, bringToFront = TRUE),
                    popup = ~popper,
                    group = "Dolphin Intensity") %>%
        addPolygons(data = gridvalues_u(),
                    fillColor = ~pro_pal(dolphins_class),
                    weight = 0.5,
                    color = "black",
                    fillOpacity = 1,
                    highlightOptions = highlightOptions(color = "white", weight = 2, bringToFront = TRUE),
                    popup = ~poppy,
                    group = "Dolphin Intensity") %>%
        leaflet::addLegend(position = 'topright',
                           pal = pro_pal,
                           values = c("None", "Moderate", "High"),
                           opacity = 1,
                           title = HTML("Dolphin Intensity"),
                           group = "Dolphin Intensity",
                           layerId = "Dolphin Intensity") 
    }
    
    if (input$radio_depred == "Dolphins" & input$radio_layer == "Density (heat)"){
      proxy %>% 
        addHeatmap(data = all_centroids() %>% filter(dolphins_class != "None"),
                   #gradient = "Spectral",
                   intensity = ~num_points,
                   blur = 35,
                   #max = 0.05,
                   radius = 30,
                   group = "Dolphin Density")
    }
    
    if (input$radio_current == "Yes"){
      proxy %>%
        clearHeatmap() %>%
        clearControls() %>%
        #clearShapes() %>%
        addControl(html=html_legend, position="topright") %>%
        addPolygons(
          data=gridvalues(),
          fillColor = ~pro_pal(current_class),
          weight = 0.5,
          color = "black",
          fillOpacity = 1,
          highlightOptions = highlightOptions(color = "white", weight = 2, bringToFront = TRUE),
          popup = ~popper,
          group = "Current Intensity") %>%
        addPolygons(data = gridvalues_u(),
                    fillColor = ~pro_pal(current_class),
                    weight = 0.5,
                    color = "black",
                    fillOpacity = 1,
                    highlightOptions = highlightOptions(color = "white", weight = 2, bringToFront = TRUE),
                    popup = ~poppy,
                    group = "Current Intensity") %>%
        leaflet::addLegend(position = 'topright',
                           pal = pro_pal,
                           values = c("None", "Moderate", "High"),
                           opacity = 1,
                           title = HTML("Current Intensity"),
                           group = "Current Intensity",
                           layerId = "Current Intensity")
    }
      
  })

# trouble shooting tables
  # observe({
  #   output$trouble_table <- DT::renderDT({
  #     all_centroids()
  #   })
  # })
  # 
  # observe({
  #   output$trouble_table2 <- DT::renderDT({
  #     grid_centroids()
  #   })
  # })
  # 
  # observe({
  #   output$trouble_table3 <- DT::renderDT({
  #     gridvalues()
  #   })
  # })

############################# 
# print number of observations in the map
  output$text_obs <- renderInfoBox({
    infoBox(
      "Total Observations",
      paste0(format(sum(nrow(filtered_data()), nrow(filtered_data_u())), big.mark=",")),
      icon=icon("binoculars"),
      color="light-blue"
    )
  })

############################
# user data tab outputs
  
  output$user_data <- DT::renderDT({
    req(credentials()$info)
    req(data_store$data)
    data_store$data %>% 
      filter(
      user_id %in% session$userData$user_id
      ) %>%
      rename("Current Intensity" = "current",
             "Depredation Intensity" = "depred",
             "Species Encountered" = "species",
             "Longitude" = "longitude",
             "Latitude" = "latitude",
             "Notes" = "notes",
             "Time Recorded (UTC)" = "timestamp",
             "User ID" = "user_id")
  })
  
  userid_data <- reactive({
    req(credentials()$info)
    req(data_store$data)
    data_store$data %>% 
      filter(!is.na(latitude) & !is.na(longitude) & user_id %in% session$userData$user_id)
  })
  
  calculateOpacity <- function(day_value) {
    # Ensure there are timestamps to work with
    if (length(day_value) == 0) return(rep(1, length(day_value)))  # Default to opacity of 1 if no data
    if (length(day_value) == 1) return(rep(1, length(day_value)))  # Default to opacity of 1 if one data point
    
    # Normalize the timestamps to get a range between 0 and 1
    current_time <- Sys.time()
    days_since <- as.numeric(difftime(current_time, day_value, units = "days"))
    
    # Normalize the opacity (0 is more recent, 1 is the furthest back)
    max_days <- max(days_since, na.rm = TRUE)
    min_days <- min(days_since, na.rm = TRUE)
    
    # Avoid division by zero
    if (max_days == min_days) {
      return(rep(1, length(day_value)))  # Default opacity if all timestamps are the same
    }
    
    normalized_day <- (days_since - min_days) / (max_days - min_days)
    opacity <- 1 - normalized_day  # More recent data will be more opaque
    
    return(opacity)
  }
  
  # Calculate colors for species
  colors_sp <- colorFactor(c("#00a65a","#3c8dbc", "#00c0ef"), levels = c("None", "Shark", "Dolphin"))
  
  # Calculate opacity for days since recording
  opacity <- reactive({
    req(userid_data())
    timestamps <- userid_data()$timestamp
    calculateOpacity(timestamps)
  })
  
  output$user_map <- renderLeaflet({
    req(credentials()$info)

    poppy <- paste0("<strong>Notes: </strong>", userid_data()$notes,
                    "<br><strong>Date Recorded: </strong>", as.Date(userid_data()$timestamp))

    umap <- leaflet() %>%
      addProviderTiles("Esri.NatGeoWorldMap", options = providerTileOptions(minZoom = 6, maxZoom = 12)) %>%
      setView(lng=-86.75, lat=29.75, zoom=9)  %>%
      addScaleBar(position = 'topleft',
                  options = scaleBarOptions(maxWidth = 100, metric = TRUE, imperial = TRUE, updateWhenIdle = FALSE)) %>%
      leafem::addMouseCoordinates() %>%
      addSimpleGraticule(interval = 1,
                         group = "Graticule") %>%
      addControl(html=html_legend, position="topright") %>%
      addLayersControl(position="topleft", overlayGroups = c("Graticule"),
                       options=layersControlOptions(collapsed=FALSE)) %>%
      addMarkers(lng=-86.3, #input$user_long
                 lat=30.25, #input$user_lat
                 icon=boat_icon) #%>%
    if (nrow(userid_data()) >= 1) {
      if (input$radio_points == "Species Encountered") {
      umap <- umap %>%
        clearGroup("Depredation Intensity") %>%
        clearGroup("Current Intensity") %>%
      addCircleMarkers(
            data=userid_data(),
            lng=~as.numeric(longitude),
            lat=~as.numeric(latitude),
            weight=3,
            radius=10,
            fillOpacity = opacity(),
            color = ~colors_sp(species),
            popup=~poppy,
            group="Species Encountered"
          ) %>%
          leaflet::addLegend(position = 'topright',
                             pal = colors_sp,
                             values = factor(c("None", "Shark", "Dolphin"), levels = c("None", "Shark", "Dolphin")),
                             opacity = 1,
                             title = HTML("Species Encountered"),
                             group = "Species Encountered",
                             layerId = "Species Encountered")
      } else if (input$radio_points == "Depredation Intensity") {
        umap <- umap %>%
          clearGroup("Species Encountered") %>%
          clearGroup("Current Intensity") %>%
          addCircleMarkers(
            data=userid_data(),
            lng=~as.numeric(longitude),
            lat=~as.numeric(latitude),
            weight=3,
            radius=10,
            fillOpacity = opacity(),
            color = ~pro_pal(depred),
            popup=~poppy,
            group="Depredation Intensity"
          ) %>%
          addLegend(
            position = 'topright',
            pal = pro_pal,
            values = factor(c("None", "Moderate", "High"), levels = c("None", "Moderate", "High")),
            opacity = 1,
            title = HTML("Depredation Intensity"),
            group = "Depredation Intensity",
            layerId = "Depredation Intensity")
      } else if (input$radio_points == "Current Intensity") {
        umap <- umap %>%
          clearGroup("Depredation Intensity") %>%
          clearGroup("Species Encountered") %>%
          addCircleMarkers(
            data=userid_data(),
            lng=~as.numeric(longitude),
            lat=~as.numeric(latitude),
            weight=3,
            radius=10,
            fillOpacity = opacity(),
            color = ~pro_pal(current),
            popup=~poppy,
            group="Current Intensity"
          ) %>%
          addLegend(
            position = 'topright',
            pal = pro_pal,
            values = factor(c("None", "Moderate", "High"), levels = c("None", "Moderate", "High")),
            opacity = 1,
            title = HTML("Current Intensity"),
            group = "Current Intensity",
            layerId = "Current Intensity")
      }
    }
    return(umap)
  })
  
} #end server
```

### ui.R

This script contains the user interface for the app in a dashboard format.

```{r ui, echo=FALSE}
dashboardPage(skin="black", 
  dashboardHeader(
    title = div(img(src="cfa-logo.png", style = "width:50px;height:50px"), "Charter Fisherman's Association"),
    titleWidth = 400,
    tags$li(class = "dropdown", shinyauthr::logoutUI(id = "logout"), style="margin-right:15px; margin-top:10px;")
  ), # dashboard header
  
  dashboardSidebar(
    width = 400,
    sidebarMenu(id="sidebarid", style="white-space: normal;",
      menuItem("Map", tabName="maptab", icon=icon("map")),
      menuItem("Record New Observation", tabName="recordtab", icon=icon("pen-to-square")),
      menuItem("User Data", tabName="usertab", icon=icon("user")),
      conditionalPanel(
        'input.sidebarid == "maptab"',
        sliderTextInput("days", "Days Since Reporting", choices=seq(from=1, to=14, by=1), selected=c(3), grid=TRUE),
        radioGroupButtons("radio_current", "Display Current Intensity", choices = c("Yes", "No"), selected="No"),
        conditionalPanel("input.radio_current == 'No'",
          radioGroupButtons("radio_depred", "Display Depredation", choices=c("Total", "Sharks", "Dolphins"), selected="Total"),
          radioGroupButtons("radio_layer", "Layer Style", choices=c("Intensity (grid)", "Density (heat)"), selected="Intensity (grid)"),
        ),
        actionButton("update", "Update Map", icon=icon("refresh"), class="btn btn-primary", style = "color: white;")
      ), # conditional panel - map tab
      conditionalPanel(
        'input.sidebarid == "usertab"',
        radioGroupButtons("radio_points", "Display Layer", choices = c("Species Encountered", "Depredation Intensity", "Current Intensity"), selected="Species Encountered", direction="vertical")
      ) # conditional panel - user tab
    ) # sidebar menu
  ), # dashboard sidebar
  
  dashboardBody(
    shinyauthr::loginUI("login"),
    div(id="main_ui",
    tabItems(
      tabItem(tabName="maptab",
        fluidRow(
          box(
            width=8, status="primary", 
            HTML("ABOUT THE DATA<br>Displayed is a combination of data collected via the NOAA Observer Program and manually recorded observations.
              The total number of observations refers to the number of points informing the map. Grid cells are 1 mi by 1 mi and reflect the average
              value of points located inside each cell. Current intensity was calculated using averages of the current speed (m/s) from 2000-2017
              during the month of October.")),
          infoBoxOutput("text_obs", width=4),
        ), # fluid row
        fluidRow(
          box(
            width=12, title = "Map", status="primary", solidHeader=TRUE, collapsible=FALSE,
            withLoader(leafletOutput("examplemap", height = 740), type="html", loader="loader4")
          ) # box - map
        ) # fluid row
      ), #tab item
      tabItem(tabName="recordtab",
        fluidRow(
        box(width=12, status="primary", title="Record New Observation", solidHeader=TRUE,
          helpText("Please enter your observations using the following inputs."),
          fluidRow(
            column(width=4, pickerInput("select_current", label = "Current Intensity", choices = c("None", "Moderate", "High"), selected = "None",
                   choicesOpt = list(
                                    content = sprintf("<span class='label label-%s'>%s</span>",
                                                      c("success", "warning", "danger"),
                                                      c("None", "Moderate", "High"))
            ))),
            column(width=4, pickerInput("select_depred", label = "Depredation Intensity", choices = c("None", "Moderate", "High"), selected = "None",
                                              choicesOpt = list(
                                                content = sprintf("<span class='label label-%s'>%s</span>",
                                                                  c("success", "warning", "danger"),
                                                                  c("None", "Moderate", "High"))
            ))),
            column(width=4, pickerInput("select_species", label = "Species Encountered", choices = c("None","Shark", "Dolphin"), selected = "None",
                                              choicesOpt = list(
                                                content = sprintf("<span class='label label-%s'>%s</span>",
                                                                  c("success", "primary", "info"),
                                                                  c("None", "Shark", "Dolphin"))
            )))
          ), # fluid row
          fluidRow(
            column(width=4, radioButtons("check_loc", label = "Use Current Location", c("Yes", "No"), selected = "Yes")),
            column(width=4, conditionalPanel(condition="input.check_loc == 'No'",
                                              textInput("text_long", label = "Longitude"))),
            column(width=4, conditionalPanel(condition="input.check_loc == 'No'",
                                              textInput("text_lat", label = "Latitude")))
          ), # fluid row
          fluidRow(
            column(width=8, textInput("text_notes", label="Notes"))
          ), # fluid row
          actionButton("submit", "Submit Data", class="btn btn-primary", style = "color: white;")
        ) # box
        ) # fluid row
      ), # tab item
      tabItem(tabName="usertab",
        fluidRow(
        box(
          width=12, title="User Data", status="primary", solidHeader=TRUE, collapsible=TRUE,
          div(DTOutput("user_data"), style="overflow-y: auto; height=300px")
        ) # box - table
        ),
        fluidRow(
        box(
          width=12, title = "Map", status="primary", solidHeader=TRUE, collapsible=TRUE, 
          withLoader(leafletOutput("user_map", height = 540), type="html", loader="loader4")
        ) # box - user map
        ) # fluid row
      ) # tab item
    ) # tab items
    ) # div main ui 
  ) # dashboard body
) # dashboard page  
```

## References
